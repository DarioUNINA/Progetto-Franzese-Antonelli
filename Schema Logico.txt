-PK
/ FK

-classi-

aree_tematiche (-nome_area-)
corsi (nome, descrizione, presenze_min, max_partetcipanti, -id_corso-, parole_chiave, terminato, /id_operatore/, anno)
lezioni (durata, titolo, descrizione, data, orario, -id_lezione-, /id_corso/)
studenti (-matricola-, nome, cognome)
operatori (-id_operatore-, nome_utente, Password)
domande_operatori(/id_operatore/, /id_domanda/, risposta)
domande_sicurezza(-id_domanda-, domanda)


presenze (/matricola/, /id_lezione/)
iscrizioni (ammesso, /matricola/, /id_corso/)  //classe d'associazione
temi (/nome_area/, /id_corso/)

-vincoli-


1)se corso é terminato non é possibile aggiungere lezioni

2)ammesso é true se le presenze dello studente sono > presenze min

3)se gli iscritti a un corso sono = max partecipanti, non é possibile aggiungere altri studenti nella tabella iscrizione 

4)un operatore puó modificare solo i corsi di cui é titolare  *DA GESTIRE CON JDBC*

5)un operatore non puó tenere piú lezioni contemporaneamente *DA GESTIRE CON JDBC*

6)un corso non puó avere due lezioni contemporaneamente

7)unique (matricola, corso) in Iscrizione

8)uno studente non si puó iscrivere a due lezioni contemporaneamente

9)Non é possibile iscriversi a lezioni giá concluse

11)Non ci si puó iscrivere a corsi terminati

12)Non è possibile iscriversi ad una lezione se non si è iscritti al corso.

13)Autoincremnto primary key

14)Minimo lunghezza password e nome_utente

15)Caratteri speciali non ammessi in nome utente e password

16) attivate trigger su update

17) eliminazione di una lezione giá terminata

18) un professore non puó creare lezioni in contemporanea ad altre sue lezioni


--1)
	CREATE FUNCTION check_inserimento_in_terminato()
	RETURNS TRIGGER AS
	$$
	DECLARE violazione INTEGER;
	BEGIN
		SELECT COUNT (*) INTO violazione
		FROM corsi s
		WHERE s.id_corso = NEW.id_corso AND s.terminato = true;
		
		IF (violazione>0) THEN
			RAISE SQLSTATE '10005';
			ROLLBACK;
			RAISE EXCEPTION 'ATTENZIONE : il corso e termianto';
		END IF;
		RETURN NEW;
	END
	$$ LANGUAGE plpgsql;

	CREATE TRIGGER inserimento_in_terminato
	AFTER INSERT ON lezioni
	FOR EACH ROW
	EXECUTE PROCEDURE check_inserimento_in_terminato();



--2)
	CREATE OR REPLACE FUNCTION check_ammissione()
	RETURNS TRIGGER AS 
	$$
	DECLARE p_min INTEGER;
			p_studente INTEGER;
			nome_corso VARCHAR(100);
	
	BEGIN
	
		SELECT l.id_corso INTO nome_corso
		FROM presenze p JOIN lezioni l ON p.id_lezione = l.id_lezione
		WHERE p.id_lezione = NEW.id_lezione;
	
		SELECT COUNT(*) INTO p_studente
		FROM presenze p JOIN lezioni l ON p.id_lezione = l.id_lezione
		WHERE p.matricola = NEW.matricola
		AND l.id_corso = nome_corso;
	
		SELECT presenze_min INTO p_min
		FROM corsi c
		WHERE c.id_corso = nome_corso;
	
		IF( p_studente >= p_min ) THEN
			UPDATE iscrizioni i SET ammesso = TRUE WHERE i.matricola = NEW.matricola AND i.id_corso =  nome_corso;
		END IF;
		RETURN NEW;
	
	END

	$$ LANGUAGE plpgsql;

	CREATE OR REPLACE TRIGGER ammissione
	AFTER INSERT ON presenze
	FOR EACH ROW
	EXECUTE PROCEDURE check_ammissione();

	

--3)
	CREATE FUNCTION check_max_partecipanti()
	RETURNS TRIGGER AS
	$$
	DECLARE iscritti INTEGER;
			max_p INTEGER;
	BEGIN
		SELECT COUNT (matricola) INTO iscritti
		FROM iscrizioni i JOIN corsi c ON i.id_corso = c.id_corso
		WHERE i.id_corso = new.id_corso;
		
		SELECT c.max_partecipanti INTO max_p
		FROM iscrizioni i JOIN corsi c ON i.id_corso = c.id_corso
		WHERE i.id_corso = NEW.id_corso;
		
		IF (iscritti > max_p) THEN	
			RAISE SQLSTATE '10006';
			ROLLBACK;
			RAISE EXCEPTION 'e stato raggiunto il numero massimo di partecipanti al corso';
		END IF;
		RETURN NEW;
	END
	$$ LANGUAGE plpgsql;

	CREATE TRIGGER max_partetcipanti
	AFTER INSERT ON iscrizioni
	FOR EACH ROW
	EXECUTE PROCEDURE check_max_partecipanti();

   
--9)	
	CREATE OR REPLACE FUNCTION check_data_lezione()
	RETURNS TRIGGER AS
	$$
	DECLARE data_lezione DATE;
	BEGIN
		SELECT data INTO data_lezione
		FROM presenze p JOIN lezioni l ON p.id_lezione = l.id_lezione
		WHERE p.id_lezione = NEW.id_lezione;
		
		IF (data_lezione < CURRENT_DATE) THEN 
			RAISE SQLSTATE '10007';
			ROLLBACK;
			RAISE EXCEPTION 'La lezione si e gia conclusa';
		END IF;
		RETURN NEW;
	END
	$$ LANGUAGE plpgsql;
	
	CREATE OR REPLACE TRIGGER data_lezioni
	AFTER INSERT ON presenze
	FOR EACH ROW
	EXECUTE PROCEDURE check_data_lezione();
	
	
--8) 
	
	CREATE FUNCTION check_presenza_contemporanea()
	RETURNS TRIGGER AS
	$$
	DECLARE violazione INTEGER;
			startt TIME WITHOUT TIME ZONE;
			endt TIME WITHOUT TIME ZONE;
            datat DATE;
	BEGIN
		
		SELECT l.orario INTO startt
		FROM lezioni l
		WHERE new.id_lezione = l.id_lezione;
		
		SELECT l.orario+l.durata INTO endt
		FROM lezioni l
		WHERE new.id_lezione = l.id_lezione;
        
		SELECT l.data into datat
		FROM lezioni l
		WHERE new.id_lezione = l.id_lezione;
		
		SELECT COUNT (*) INTO violazione
		FROM presenze pr JOIN lezioni le ON pr.id_lezione = le.id_lezione
		WHERE pr.matricola = NEW.matricola AND le.data = datat AND ((le.orario BETWEEN startt AND endt) OR (le.orario+le.durata BETWEEN startt AND endt) OR (le.orario < startt AND le.orario+le.durata > endt)); 	
    
        IF (violazione > 1) THEN	
			RAISE SQLSTATE '10008';
			ROLLBACK;
			RAISE EXCEPTION 'Ti sei gia iscritto ad una lezione in contemporanea';
		END IF;
		RETURN NEW;
	END
	
	$$ LANGUAGE plpgsql;
	
	CREATE TRIGGER presenza_contemporanea
	AFTER INSERT ON iscrizioni
	FOR EACH ROW
	EXECUTE PROCEDURE check_presenza_contemporanea();
	
--11)
	CREATE FUNCTION check_iscrizione_terminato()
	RETURNS TRIGGER AS
	$$
	DECLARE violazione INTEGER;
	BEGIN
		SELECT COUNT (*) INTO violazione 
		FROM corsi c JOIN iscrizioni i ON c.id_corso = i.id_corso
		WHERE i.id_corso = new.id_corso AND c.terminato = true;
		
		IF violazione > 0 THEN
		RAISE SQLSTATE '10009';
		ROLLBACK;
		RAISE EXCEPTION 'Il corso gia e terminato';
		END IF;
		RETURN NEW;
	END
	
	$$ LANGUAGE plpgsql;
	
	CREATE TRIGGER iscrizione_in_terminato
	AFTER INSERT ON iscrizioni
	FOR EACH ROW
	EXECUTE PROCEDURE check_iscrizione_terminato();

--12) 
	CREATE FUNCTION check_lezione_iscrizione()
	RETURNS TRIGGER AS
	$$
	DECLARE contatore INTEGER;
	BEGIN
		SELECT COUNT (*) INTO contatore
		FROM presenze p JOIN lezioni l ON p.id_lezione = l.id_lezione
		WHERE p.id_lezione = NEW.id_lezione AND l.id_corso IN (
		
		SELECT i.id_corso
		FROM iscrizioni i
		WHERE i.matricola = NEW.matricola);
		
		IF contatore = 0 THEN
			RAISE SQLSTATE '10010';
			ROLLBACK;
			RAISE EXCEPTION 'Non sei iscritto al corso';
		END IF;
		RETURN NEW;
	END;
	
	$$ LANGUAGE plpgsql;
	
	CREATE TRIGGER lezione_iscrizione
	AFTER INSERT ON presenze
	FOR EACH ROW
	EXECUTE PROCEDURE check_lezione_iscrizione();
	
	
--14)	
	CREATE FUNCTION check_lunghezza_password()
	RETURNS TRIGGER AS
	$$
	DECLARE index INTEGER;
			stringa VARCHAR(100);
	BEGIN
		SELECT o.password INTO stringa
		FROM operatori o
		WHERE o.nome_utente = NEW.nome_utente;
		
		stringa = SUBSTRING(stringa, 6, 100);
		IF(stringa = '')THEN
			RAISE SQLSTATE '10001';
			ROLLBACK;
			RAISE EXCEPTION 'La password deve contentere almeno 8 caratteri';
		END IF;
		RETURN NEW;
	END
	$$ LANGUAGE plpgsql;

	CREATE TRIGGER lunghezza_password_violata
	AFTER INSERT ON operatori
	FOR EACH ROW
	EXECUTE PROCEDURE check_lunghezza_password();
	
	
	
	
	CREATE FUNCTION check_lunghezza_nome_utente()
	RETURNS TRIGGER AS
	$$
	DECLARE index INTEGER;
			stringa VARCHAR(100);
	BEGIN
		SELECT o.nome_utente INTO stringa
		FROM operatori o
		WHERE o.nome_utente = NEW.nome_utente;
		
		stringa = SUBSTRING(stringa, 4, 100);
		IF(stringa = '')THEN
			RAISE SQLSTATE '10002';
			ROLLBACK;
			RAISE EXCEPTION 'Il nome utente deve contentere almeno 8 caratteri';
		END IF;
		RETURN NEW;
	END
	$$ LANGUAGE plpgsql;

	CREATE TRIGGER lunghezza_nome_utente_violata
	AFTER INSERT ON operatori
	FOR EACH ROW
	EXECUTE PROCEDURE check_lunghezza_nome_utente();
	
--15)
	CREATE FUNCTION check_caratteri_speciali_nome_utente()
	RETURNS TRIGGER AS
	$$
	DECLARE violazione INTEGER;
	BEGIN
		SELECT COUNT(*) INTO violazione
		FROM operatori o
		WHERE o.nome_utente = NEW.nome_utente AND 
			( o.nome_utente like '%!%' OR o.nome_utente like '%@%' OR o.nome_utente like '%#%' OR o.nome_utente like '%$%');
		
		IF(violazione>0)THEN
			RAISE SQLSTATE '10003';
			ROLLBACK;
			RAISE EXCEPTION 'Il nome utente non puo contenere caratteri speciali';
		END IF;
		RETURN NEW;
	END
	$$ LANGUAGE plpgsql;

	CREATE TRIGGER nome_utente_caratteri_speciali
	AFTER INSERT ON operatori
	FOR EACH ROW
	EXECUTE PROCEDURE check_caratteri_speciali_nome_utente();
	
	
	
	CREATE FUNCTION check_caratteri_speciali_password()
	RETURNS TRIGGER AS
	$$
	DECLARE violazione INTEGER;
	BEGIN
		SELECT COUNT(*) INTO violazione
		FROM operatori o
		WHERE o.password like '%!%' OR o.password like '%@%' OR o.password like '%#%' OR o.password like '%$%';
		
		IF(violazione>0)THEN
			RAISE SQLSTATE '10004';
			ROLLBACK;
			RAISE EXCEPTION 'La password non puo contenere caratteri speciali';
		END IF;
		RETURN NEW;
	END
	$$ LANGUAGE plpgsql;

	CREATE TRIGGER password_caratteri_speciali
	AFTER INSERT ON operatori
	FOR EACH ROW
	EXECUTE PROCEDURE check_caratteri_speciali_password();
	
--16) Trigger per gli update
		

	CREATE TRIGGER update_nome_utente_caratteri_speciali
	AFTER UPDATE ON operatori
	FOR EACH ROW
	EXECUTE PROCEDURE check_caratteri_speciali_nome_utente();
	
	
	CREATE TRIGGER update_password_caratteri_speciali
	AFTER UPDATE ON operatori
	FOR EACH ROW
	EXECUTE PROCEDURE check_caratteri_speciali_password();
	
	CREATE TRIGGER update_lunghezza_password_violata
	AFTER UPDATE ON operatori
	FOR EACH ROW
	EXECUTE PROCEDURE check_lunghezza_password();
	
	CREATE TRIGGER update_lunghezza_nome_utente_violata
	AFTER UPDATE ON operatori
	FOR EACH ROW
	EXECUTE PROCEDURE check_lunghezza_nome_utente();
	
--17) 
	CREATE OR REPLACE FUNCTION check_eliminazione_presenza()
	RETURNS TRIGGER AS
	$$
	DECLARE data_lezione DATE;
	BEGIN
		SELECT data INTO data_lezione
		FROM presenze p JOIN lezioni l ON p.id_lezione = l.id_lezione
		WHERE p.id_lezione = OLD.id_lezione;
		
		IF (data_lezione < CURRENT_DATE) THEN 
			RAISE SQLSTATE '10011';
			ROLLBACK;
			RAISE EXCEPTION 'La lezione si e gia conclusa';
		END IF;
		RETURN OLD;
	END
	$$ LANGUAGE plpgsql;
	
	CREATE OR REPLACE TRIGGER eliminazione_presenza
	AFTER DELETE ON presenze
	FOR EACH ROW
	EXECUTE PROCEDURE check_eliminazione_presenza();
	

--18)
	CREATE FUNCTION check_creazione_lezione_contemporanea()
	RETURNS TRIGGER AS
	$$
	DECLARE violazione INTEGER;
			startt TIME WITHOUT TIME ZONE;
			endt TIME WITHOUT TIME ZONE;
            datat DATE;
	BEGIN
		
		SELECT l.orario INTO startt
		FROM lezioni l
		WHERE new.id_lezione = l.id_lezione;
		
		SELECT l.orario+l.durata INTO endt
		FROM lezioni l
		WHERE new.id_lezione = l.id_lezione;
        
		SELECT l.data into datat
		FROM lezioni l
		WHERE new.id_lezione = l.id_lezione;
		
		SELECT COUNT (*) INTO violazione
		FROM lezioni le
		WHERE le.id_corso = NEW.id_corso AND le.data = datat AND ((le.orario BETWEEN startt AND endt) OR (le.orario+le.durata BETWEEN startt AND endt) OR (le.orario < startt AND le.orario+le.durata > endt)); 	
    
        IF (violazione > 1) THEN	
			RAISE SQLSTATE '10012';
			ROLLBACK;
			RAISE EXCEPTION 'Hai gia lezioni allo stesso orario dello stesso giorno';
		END IF;
		RETURN NEW;
	END
	
	$$ LANGUAGE plpgsql;
	
	CREATE TRIGGER creazione_lezione_contemporanea
	AFTER INSERT ON lezioni
	FOR EACH ROW
	EXECUTE PROCEDURE check_creazione_lezione_contemporanea();